#+title: Lab5
#+PROPERTY: header-args:python   :session *lab4* :exports both :eval no-export :async
#+PROPERTY: header-args:latex   :noweb yes
* Lab 5: Parsing, building an Abstract Syntax Tree
- Course :: Formal Languages & Finite Automata
- Author :: Balan Artiom

* Theory
There are a dozen different parsers with different workings and different capabilities.
The easiest to implement seems to be the so-called [[https://en.wikipedia.org/wiki/Recursive_descent_parser][Recursive descent parser]].
To put it shortly, it is implemented by writing a function for every non-terminal in the grammar
which picks a suitable production from that non-terminal, consumes the tokens
and calls some other such functions when it meets other non-terminals,
then returns a part of the AST corresponding to its non-terminal.
Once we have such functions for every non-terminal,
we simply call the function for the starting symbol (e.g. =program=)
and watch in awe the magic of recursion do its thing..
* Objectives
- [X] Use a TokenType enum
- [X] Use regex in the lexer
- [X] Implement a parser that returns an AST
* Results
* Implementation
